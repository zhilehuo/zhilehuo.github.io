---
title: JVM 内存区域
date: 2018-03-27 10:36:14
tags:
- JVM
categories:
- Tech
---
JVM 在执行 Java 程序的过程中会把它所管理的内存划分为如下几个数据区域：

* 程序计数器
* 虚拟机栈
* 本地方法栈 
* 堆
* 方法区


<!--more-->


## 程序计数器

程序计数器是一块很小的内存空间，是当前线程所执行字节码的行号指示器，线程间私有不共享。执行 Java 方法时计数器的值为字节码指令的地址，执行 Native 方法时值为空。不会出现OutOfMemoryError。



## 虚拟机栈

虚拟机栈为线程私有，生命周期与线程相同，描述 Java 方法执行的内存模型。方法执行时创建栈帧，用于存储局部变量表、操作数栈、方法出口等信息。

局部变量表存放了编译器可知的基本数据类型、对象引用和 returnAddress类型（字节码指令地址），所需内存空间在编译器完成分配，运行期间不改变大小。

线程请求栈深度大于虚拟机允许深度时抛出 StackOverflowError（大部分虚拟机可以动态扩容，但也允许固定长度的虚拟机栈），扩展时无法申请到足够内存抛出 OutOfMemoryError。



## 本地方法栈

本地方法栈为虚拟机执行 Native 方法服务，线程隔离。虚拟机规范中无强制规定，Sun HostSpot 将本地方法栈和虚拟机栈合二为一。能够抛出 StackOverflowError 和 OutOfMemoryError 异常。



## Java 堆

Java 堆是 JVM 所管理内存中最大的一块，所有线程共享，在虚拟机启动时创建，用于存放对象实例，是垃圾回收的主要区域。

从内存回收的角度可分为新生代和老年代，再细致划分可分为 Eden 空间、From Survivor 空间 和 To Survivor 空间等。

Java 堆可以处于物理上不连续的内存空间内，只要逻辑上连续即可。

在堆中没有内存完成实例分配也无法再扩展时抛出 OutOfMemoryError。



## 方法区

方法区由各个线程共享，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等。

JVM 规范把方法区描述为堆的一个逻辑部分，别名 Non-Heap（目的是与 Java 堆区分开）。

在 JDK6 和 JDK7 中，HotSpot 选择将 GC 分代收集扩展至方法区，可以理解为 永久代。

在 JDK8 中使用元数据区 Metaspace 取代永久代，元数据被分配到本地内存中进行管理，Metaspace 默认上限是本地内存大小。

JVM 规范对方法区的限制非常宽松，不需要连续内存、固定大小或可扩展均可，还可以不实现垃圾回收。垃圾收集行为在这个区域较少出现。

方法区包含运行时常量池，Class 文件中的常量信息在类加载后存放于运行时常量池中。运行时常量池具备动态性，运行期间也可能将新的常量放入池中。

当方法区无法满足内存分配需求时会抛出 OutOfMemoryError。



## 直接内存 *

直接内存不是 JVM 运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，但这部分内存会被频繁使用，而且可能会导致 OutOfMemoryError 异常。

JDK 1.4 中新加入的NIO（New Input / Output）类引入了一种基于通道与缓冲区的 IO 方式，可以使用 Native 函数库直接分配堆外内存，再通过存储在 Java 堆中的DirectByteBuffer 对象做为这块内存的引用进行操作。

与堆相比，直接内存的申请成本更高，IO 读写的性能更强。

直接内存不受 Java 堆大小限制，但会受到本机总内存及处理器寻址空间限制，动态扩展超出限制会抛出 OutOfMemoryError 异常。
